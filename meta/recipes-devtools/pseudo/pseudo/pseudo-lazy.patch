commit ea164793f758c2f85ac891bf50f29307e664572d
Author: Mark Hatle <mark.hatle@windriver.com>
Date:   Wed Oct 12 17:43:15 2011 -0500

    Add Lazy symbol resolution
    
    In some cases this should improve performance.
    
    Signed-off-by: Mark Hatle <mark.hatle@windriver.com>

diff --git a/ports/common/guts/execl.c b/ports/common/guts/execl.c
index ce908ed..46056a6 100644
--- a/ports/common/guts/execl.c
+++ b/ports/common/guts/execl.c
@@ -6,6 +6,7 @@
  *	int rc = -1;
  */
 
+	PSEUDO_USE_REAL(execl, return rc;);
 	rc = real_execl(file, arg, ap);
 
 /*	return rc;
diff --git a/ports/common/guts/execle.c b/ports/common/guts/execle.c
index 68d8bba..73904f8 100644
--- a/ports/common/guts/execle.c
+++ b/ports/common/guts/execle.c
@@ -6,6 +6,7 @@
  *	int rc = -1;
  */
 
+	PSEUDO_USE_REAL(execle, return rc;);
 	rc = real_execle(file, arg, ap);
 
 /*	return rc;
diff --git a/ports/common/guts/execlp.c b/ports/common/guts/execlp.c
index d357986..a53eb9f 100644
--- a/ports/common/guts/execlp.c
+++ b/ports/common/guts/execlp.c
@@ -6,6 +6,7 @@
  *	int rc = -1;
  */
 
+	PSEUDO_USE_REAL(execlp, return rc;);
 	rc = real_execlp(file, arg, ap);
 
 /*	return rc;
diff --git a/ports/common/guts/execv.c b/ports/common/guts/execv.c
index 35f8de5..073bc1f 100644
--- a/ports/common/guts/execv.c
+++ b/ports/common/guts/execv.c
@@ -29,6 +29,7 @@
 	 * not much we can do about that.
 	 */
 	sigprocmask(SIG_SETMASK, &pseudo_saved_sigmask, NULL);
+	PSEUDO_USE_REAL(execv, return rc;);
 	rc = real_execv(file, argv);
 
 /*	return rc;
diff --git a/ports/common/guts/execve.c b/ports/common/guts/execve.c
index db68b8e..d8ba6d3 100644
--- a/ports/common/guts/execve.c
+++ b/ports/common/guts/execve.c
@@ -30,6 +30,7 @@
 	 * not much we can do about that.
 	 */
 	sigprocmask(SIG_SETMASK, &pseudo_saved_sigmask, NULL);
+	PSEUDO_USE_REAL(execve, return rc;);
 	rc = real_execve(file, argv, new_environ);
 
 /*	return rc;
diff --git a/ports/common/guts/execvp.c b/ports/common/guts/execvp.c
index 4332c83..08d2e1f 100644
--- a/ports/common/guts/execvp.c
+++ b/ports/common/guts/execvp.c
@@ -30,6 +30,7 @@
 	 * not much we can do about that.
 	 */
 	sigprocmask(SIG_SETMASK, &pseudo_saved_sigmask, NULL);
+	PSEUDO_USE_REAL(execvp, return rc;);
 	rc = real_execvp(file, argv);
 
 /*	return rc;
diff --git a/ports/common/guts/fork.c b/ports/common/guts/fork.c
index cc7b33f..df215ad 100644
--- a/ports/common/guts/fork.c
+++ b/ports/common/guts/fork.c
@@ -6,6 +6,7 @@
  * wrap_fork(void) {
  *	int rc = -1;
  */
+	PSEUDO_USE_REAL(fork, return rc;);
 	rc = real_fork();
 	/* special case: we may want to enable or disable
 	 * pseudo in the child process
diff --git a/ports/common/pseudo_wrappers.c b/ports/common/pseudo_wrappers.c
index 2cfc400..9751ec1 100644
--- a/ports/common/pseudo_wrappers.c
+++ b/ports/common/pseudo_wrappers.c
@@ -201,7 +201,7 @@ execv(const char *file, char *const *argv) {
 	
 	int rc = -1;
 
-	if (!pseudo_check_wrappers() || !real_execv) {
+	if (!pseudo_check_wrappers()) {
 		/* rc was initialized to the "failure" value */
 		pseudo_enosys("execv");
 		return rc;
@@ -235,7 +235,7 @@ execve(const char *file, char *const *argv, char *const *envp) {
 	
 	int rc = -1;
 
-	if (!pseudo_check_wrappers() || !real_execve) {
+	if (!pseudo_check_wrappers()) {
 		/* rc was initialized to the "failure" value */
 		pseudo_enosys("execve");
 		return rc;
@@ -269,7 +269,7 @@ execvp(const char *file, char *const *argv) {
 	
 	int rc = -1;
 
-	if (!pseudo_check_wrappers() || !real_execvp) {
+	if (!pseudo_check_wrappers()) {
 		/* rc was initialized to the "failure" value */
 		pseudo_enosys("execvp");
 		return rc;
@@ -303,7 +303,7 @@ fork(void) {
 	
 	int rc = -1;
 
-	if (!pseudo_check_wrappers() || !real_fork) {
+	if (!pseudo_check_wrappers()) {
 		/* rc was initialized to the "failure" value */
 		pseudo_enosys("fork");
 		return rc;
diff --git a/ports/darwin/guts/fcntl.c b/ports/darwin/guts/fcntl.c
index ef42b33..e7ab570 100644
--- a/ports/darwin/guts/fcntl.c
+++ b/ports/darwin/guts/fcntl.c
@@ -13,6 +13,7 @@
 	va_start(ap, cmd);
 	flag = va_arg(ap, long long);
 	va_end(ap);
+	PSEUDO_USE_REAL(fcntl, return rc;);
 	rc = real_fcntl(fd, cmd, flag);
 
 	switch (cmd) {
diff --git a/ports/darwin/guts/fgetgrent_r.c b/ports/darwin/guts/fgetgrent_r.c
index e760cdd..835b3b7 100644
--- a/ports/darwin/guts/fgetgrent_r.c
+++ b/ports/darwin/guts/fgetgrent_r.c
@@ -6,6 +6,7 @@
  *	int rc = -1;
  */
 
+	PSEUDO_USE_REAL(fgetgrent_r, return rc;);
 	rc = real_fgetgrent_r(fp, gbuf, buf, buflen, gbufp);
 
 /*	return rc;
diff --git a/ports/darwin/guts/fgetpwent_r.c b/ports/darwin/guts/fgetpwent_r.c
index cfea5b8..dee6620 100644
--- a/ports/darwin/guts/fgetpwent_r.c
+++ b/ports/darwin/guts/fgetpwent_r.c
@@ -6,6 +6,7 @@
  *	int rc = -1;
  */
 
+	PSEUDO_USE_REAL(fgetpwent_r, return rc;);
 	rc = real_fgetpwent_r(fp, pbuf, buf, buflen, pbufp);
 
 /*	return rc;
diff --git a/ports/darwin/guts/fgetxattr.c b/ports/darwin/guts/fgetxattr.c
index 1cd8904..67cf9c9 100644
--- a/ports/darwin/guts/fgetxattr.c
+++ b/ports/darwin/guts/fgetxattr.c
@@ -6,6 +6,7 @@
  *	ssize_t rc = -1;
  */
 
+	PSEUDO_USE_REAL(fgetxattr, return rc;);
 	rc = real_fgetxattr(filedes, name, value, size, position, options);
 
 /*	return rc;
diff --git a/ports/darwin/guts/flistxattr.c b/ports/darwin/guts/flistxattr.c
index 7575f28..a1e1615 100644
--- a/ports/darwin/guts/flistxattr.c
+++ b/ports/darwin/guts/flistxattr.c
@@ -6,6 +6,7 @@
  *	ssize_t rc = -1;
  */
 
+	PSEUDO_USE_REAL(flistxattr, return rc;);
 	rc = real_flistxattr(filedes, list, size, options);
 
 /*	return rc;
diff --git a/ports/darwin/guts/fsetxattr.c b/ports/darwin/guts/fsetxattr.c
index 541569a..41cf949 100644
--- a/ports/darwin/guts/fsetxattr.c
+++ b/ports/darwin/guts/fsetxattr.c
@@ -6,6 +6,7 @@
  *	int rc = -1;
  */
 
+	PSEUDO_USE_REAL(fsetxattr, return rc;);
 	rc = real_fsetxattr(filedes, name, value, size, position, options);
 
 /*	return rc;
diff --git a/ports/darwin/guts/fstat.c b/ports/darwin/guts/fstat.c
index 7695147..bdcbd4e 100644
--- a/ports/darwin/guts/fstat.c
+++ b/ports/darwin/guts/fstat.c
@@ -7,6 +7,7 @@
  */
 	pseudo_msg_t *msg;
 
+	PSEUDO_USE_REAL(fstat, return rc;);
 	rc = real_fstat(fd, buf);
 
 	if (rc == -1) {
diff --git a/ports/darwin/guts/getgrent_r.c b/ports/darwin/guts/getgrent_r.c
index 9d5db5a..3eb3c5e 100644
--- a/ports/darwin/guts/getgrent_r.c
+++ b/ports/darwin/guts/getgrent_r.c
@@ -6,6 +6,7 @@
  *	int rc = -1;
  */
 
+	PSEUDO_USE_REAL(getgrent_r, return rc;);
 	rc = real_getgrent_r(gbuf, buf, buflen, gbufp);
 
 /*	return rc;
diff --git a/ports/darwin/guts/getpwent_r.c b/ports/darwin/guts/getpwent_r.c
index 3de41b9..e090510 100644
--- a/ports/darwin/guts/getpwent_r.c
+++ b/ports/darwin/guts/getpwent_r.c
@@ -6,6 +6,7 @@
  *	int rc = -1;
  */
 
+	PSEUDO_USE_REAL(getpwent_r, return rc;);
 	rc = real_getpwent_r(pwbuf, buf, buflen, pwbufp);
 
 /*	return rc;
diff --git a/ports/darwin/guts/getxattr.c b/ports/darwin/guts/getxattr.c
index 16f0993..41e491e 100644
--- a/ports/darwin/guts/getxattr.c
+++ b/ports/darwin/guts/getxattr.c
@@ -6,6 +6,7 @@
  *	ssize_t rc = -1;
  */
 
+	PSEUDO_USE_REAL(getxattr, return rc;);
 	rc = real_getxattr(pathname, name, value, size, position, options);
 
 /*	return rc;
diff --git a/ports/darwin/guts/listxattr.c b/ports/darwin/guts/listxattr.c
index 0bba451..4cdef8c 100644
--- a/ports/darwin/guts/listxattr.c
+++ b/ports/darwin/guts/listxattr.c
@@ -6,6 +6,7 @@
  *	ssize_t rc = -1;
  */
 
+	PSEUDO_USE_REAL(listxattr, return rc;);
 	rc = real_listxattr(pathname, list, size, options);
 
 /*	return rc;
diff --git a/ports/darwin/guts/lstat.c b/ports/darwin/guts/lstat.c
index 01e0f30..783c252 100644
--- a/ports/darwin/guts/lstat.c
+++ b/ports/darwin/guts/lstat.c
@@ -8,6 +8,7 @@
 
 	pseudo_msg_t *msg;
 
+	PSEUDO_USE_REAL(lstat, return rc;);
 	rc = real_lstat(path, buf);
 	if (rc == -1) {
 		return rc;
diff --git a/ports/darwin/guts/open.c b/ports/darwin/guts/open.c
index dba6800..cb40dbe 100644
--- a/ports/darwin/guts/open.c
+++ b/ports/darwin/guts/open.c
@@ -13,6 +13,7 @@
 	/* if a creation has been requested, check whether file exists */
 	if (flags & O_CREAT) {
 		save_errno = errno;
+		PSEUDO_USE_REAL(stat, return rc;);
 		rc = real_stat(path, &buf);
 		existed = (rc != -1);
 		if (!existed)
@@ -25,11 +26,13 @@
 	 * is if a file is going to be created, in which case it's
 	 * not a directory.
 	 */
+	PSEUDO_USE_REAL(open, return rc;);
 	rc = real_open(path, flags, PSEUDO_FS_MODE(mode, 0));
 	save_errno = errno;
 
 	if (rc != -1) {
 		int stat_rc;
+		PSEUDO_USE_REAL(stat, return rc;);
 		stat_rc = real_stat(path, &buf);
 
 		if (stat_rc != -1) {
diff --git a/ports/darwin/guts/scandir.c b/ports/darwin/guts/scandir.c
index 6492b1b..a4bac9b 100644
--- a/ports/darwin/guts/scandir.c
+++ b/ports/darwin/guts/scandir.c
@@ -7,6 +7,7 @@
  *	int rc = -1;
  */
 
+	PSEUDO_USE_REAL(scandir, return rc;);
 	rc = real_scandir(path, namelist, filter, compar);
 
 /*	return rc;
diff --git a/ports/darwin/guts/setxattr.c b/ports/darwin/guts/setxattr.c
index 3c8fd3d..84a691a 100644
--- a/ports/darwin/guts/setxattr.c
+++ b/ports/darwin/guts/setxattr.c
@@ -6,6 +6,7 @@
  *	int rc = -1;
  */
 
+	PSEUDO_USE_REAL(setxattr, return rc;);
 	rc = real_setxattr(pathname, name, value, size, position, options);
 
 /*	return rc;
diff --git a/ports/darwin/guts/stat.c b/ports/darwin/guts/stat.c
index 1e1cf67..c114cb5 100644
--- a/ports/darwin/guts/stat.c
+++ b/ports/darwin/guts/stat.c
@@ -9,6 +9,7 @@
 	pseudo_msg_t *msg;
 	int save_errno;
 
+	PSEUDO_USE_REAL(stat, return rc;);
 	rc = real_stat(path, buf);
 	if (rc == -1) {
 		return rc;
diff --git a/ports/linux/guts/__fxstat.c b/ports/linux/guts/__fxstat.c
index db9716b..50b22aa 100644
--- a/ports/linux/guts/__fxstat.c
+++ b/ports/linux/guts/__fxstat.c
@@ -9,6 +9,7 @@
 
 	struct stat64 buf64;
 	/* populate buffer with complete data */
+	PSEUDO_USE_REAL(__fxstat, return rc;);
 	real___fxstat(ver, fd, buf);
 	/* obtain fake data */
 	rc = wrap___fxstat64(ver, fd, &buf64);
diff --git a/ports/linux/guts/__fxstat64.c b/ports/linux/guts/__fxstat64.c
index 92c8219..7e88968 100644
--- a/ports/linux/guts/__fxstat64.c
+++ b/ports/linux/guts/__fxstat64.c
@@ -9,6 +9,7 @@
 	pseudo_msg_t *msg;
 	int save_errno;
 
+	PSEUDO_USE_REAL(__fxstat64, return rc;);
 	rc = real___fxstat64(ver, fd, buf);
 	save_errno = errno;
 	if (rc == -1) {
diff --git a/ports/linux/guts/__fxstatat.c b/ports/linux/guts/__fxstatat.c
index 94c5ff6..01a5c3a 100644
--- a/ports/linux/guts/__fxstatat.c
+++ b/ports/linux/guts/__fxstatat.c
@@ -15,11 +15,14 @@
 		return -1;
 	}
 	if (flags & AT_SYMLINK_NOFOLLOW) {
+		PSEUDO_USE_REAL(__lxstat, return -1;);
 		rc = real___lxstat(ver, path, buf);
 	} else {
+		PSEUDO_USE_REAL(__xstat, return -1;);
 		rc = real___xstat(ver, path, buf);
 	}
 #else
+	PSEUDO_USE_REAL(__fxstatat, return -1;);
 	real___fxstatat(ver, dirfd, path, buf, flags);
 #endif
 	/* obtain fake data */
diff --git a/ports/linux/guts/__fxstatat64.c b/ports/linux/guts/__fxstatat64.c
index f8a9298..f791abc 100644
--- a/ports/linux/guts/__fxstatat64.c
+++ b/ports/linux/guts/__fxstatat64.c
@@ -17,8 +17,10 @@
 #endif
 	if (flags & AT_SYMLINK_NOFOLLOW) {
 #ifdef PSEUDO_NO_REAL_AT_FUNCTIONS
+		PSEUDO_USE_REAL(__lxstat64, return -1;);
 		rc = real___lxstat64(ver, path, buf);
 #else
+		PSEUDO_USE_REAL(__fxstatat64, return -1;);
 		rc = real___fxstatat64(ver, dirfd, path, buf, flags);
 #endif
 		if (rc == -1) {
@@ -26,8 +28,10 @@
 		}
 	} else {
 #ifdef PSEUDO_NO_REAL_AT_FUNCTIONS
+		PSEUDO_USE_REAL(__lxstat64, return -1;);
 		rc = real___xstat64(ver, path, buf);
 #else
+		PSEUDO_USE_REAL(__fxstatat64, return -1;);
 		rc = real___fxstatat64(ver, dirfd, path, buf, flags);
 #endif
 		if (rc == -1) {
diff --git a/ports/linux/guts/__xmknodat.c b/ports/linux/guts/__xmknodat.c
index 59b4f2f..31dd5ec 100644
--- a/ports/linux/guts/__xmknodat.c
+++ b/ports/linux/guts/__xmknodat.c
@@ -17,8 +17,10 @@
 		errno = ENOSYS;
 		return -1;
 	}
+	PSEUDO_USE_REAL(__xstat64, return -1;);
 	rc = real___xstat64(_STAT_VER, path, &buf);
 #else
+	PSEUDO_USE_REAL(__fxstatat64, return -1;);
 	rc = real___fxstatat64(_STAT_VER, dirfd, path, &buf, AT_SYMLINK_NOFOLLOW);
 #endif
 	if (rc != -1) {
@@ -31,20 +33,24 @@
 		return -1;
 	}
 #ifdef PSEUDO_NO_REAL_AT_FUNCTIONS
+	PSEUDO_USE_REAL(open, return -1;);
 	rc = real_open(path, O_CREAT | O_WRONLY | O_EXCL,
 		PSEUDO_FS_MODE(mode, 0));
 #else
+	PSEUDO_USE_REAL(openat, return -1;);
 	rc = real_openat(dirfd, path, O_CREAT | O_WRONLY | O_EXCL,
 		PSEUDO_FS_MODE(mode, 0));
 #endif
 	if (rc == -1) {
 		return -1;
 	}
+	PSEUDO_USE_REAL(__fxstat64, return -1;);
 	real___fxstat64(_STAT_VER, rc, &buf);
 	/* mknod does not really open the file.  We don't have
 	 * to use wrap_close because we've never exposed this file
 	 * descriptor to the client code.
 	 */
+	PSEUDO_USE_REAL(close, return -1;);
 	real_close(rc);
 
 	/* mask in the mode type bits again */
@@ -62,8 +68,10 @@
 	if (rc == -1) {
 		int save_errno = errno;
 #ifdef PSEUDO_NO_REAL_AT_FUNCTIONS
+		PSEUDO_USE_REAL(unlink, return -1;);
 		real_unlink(path);
 #else
+		PSEUDO_USE_REAL(unlinkat, return -1;);
 		real_unlinkat(dirfd, path, AT_SYMLINK_NOFOLLOW);
 #endif
 		errno = save_errno;
diff --git a/ports/linux/guts/fcntl.c b/ports/linux/guts/fcntl.c
index 2e3e96d..81ef374 100644
--- a/ports/linux/guts/fcntl.c
+++ b/ports/linux/guts/fcntl.c
@@ -21,6 +21,7 @@
 	case F_DUPFD_CLOEXEC:
 #endif
 		/* actually do something */
+		PSEUDO_USE_REAL(fcntl, return rc;);
 		rc = real_fcntl(fd, cmd, arg);
 		save_errno = errno;
 		if (rc != -1) {
@@ -35,6 +36,7 @@
 	case F_GETOWN:
 	case F_GETSIG:
 	case F_GETLEASE:
+		PSEUDO_USE_REAL(fcntl, return rc;);
 		rc = real_fcntl(fd, cmd);
 		break;
 	/* long argument */
@@ -44,12 +46,14 @@
 	case F_SETSIG:
 	case F_SETLEASE:
 	case F_NOTIFY:
+		PSEUDO_USE_REAL(fcntl, return rc;);
 		rc = real_fcntl(fd, cmd, arg);
 		break;
 	/* struct flock * argument */
 	case F_GETLK:
 	case F_SETLK:
 	case F_SETLKW:
+		PSEUDO_USE_REAL(fcntl, return rc;);
 		rc = real_fcntl(fd, cmd, lock);
 		break;
 #if defined(F_GETLK64) && (F_GETLK64 != F_GETLK)
@@ -57,12 +61,14 @@
 	case F_GETLK64:
 	case F_SETLK64:
 	case F_SETLKW64:
+		PSEUDO_USE_REAL(fcntl, return rc;);
 		rc = real_fcntl(fd, cmd, (struct flock64 *) lock);
 		break;
 #endif
 	default:
 		pseudo_diag("unknown fcntl argument %d, assuming long argument.\n",
 			cmd);
+		PSEUDO_USE_REAL(fcntl, return rc;);
 		rc = real_fcntl(fd, cmd, arg);
 		break;
 	}
diff --git a/ports/linux/guts/fopen64.c b/ports/linux/guts/fopen64.c
index b2724de..3f80cb2 100644
--- a/ports/linux/guts/fopen64.c
+++ b/ports/linux/guts/fopen64.c
@@ -9,8 +9,10 @@
  	struct stat64 buf;
 	int save_errno;
 
+	PSEUDO_USE_REAL(__xstat64, return rc;);
 	int existed = (real___xstat64(_STAT_VER, path, &buf) != -1);
 
+	PSEUDO_USE_REAL(fopen64, return rc;);
 	rc = real_fopen64(path, mode);
 	save_errno = errno;
 
@@ -18,6 +20,7 @@
 		int fd = fileno(rc);
 
 		pseudo_debug(2, "fopen64 '%s': fd %d <FILE %p>\n", path, fd, (void *) rc);
+		PSEUDO_USE_REAL(__fxstat64, return rc;);
 		if (real___fxstat64(_STAT_VER, fd, &buf) != -1) {
 			if (!existed) {
 				pseudo_client_op(OP_CREAT, 0, -1, -1, path, &buf);
diff --git a/ports/linux/guts/freopen64.c b/ports/linux/guts/freopen64.c
index b8e576b..f28ddf0 100644
--- a/ports/linux/guts/freopen64.c
+++ b/ports/linux/guts/freopen64.c
@@ -8,8 +8,10 @@
  */
  	struct stat64 buf;
 	int save_errno;
+	PSEUDO_USE_REAL(__xstat64, return rc;);
 	int existed = (real___xstat64(_STAT_VER, path, &buf) != -1);
 
+	PSEUDO_USE_REAL(freopen64, return rc;);
 	rc = real_freopen64(path, mode, stream);
 	save_errno = errno;
 
@@ -17,6 +19,7 @@
 		int fd = fileno(rc);
 
 		pseudo_debug(2, "freopen64 '%s': fd %d\n", path, fd);
+		PSEUDO_USE_REAL(__fxstat64, return rc;);
 		if (real___fxstat64(_STAT_VER, fd, &buf) != -1) {
 			if (!existed) {
 				pseudo_client_op(OP_CREAT, 0, -1, -1, path, &buf);
diff --git a/ports/linux/guts/ftw64.c b/ports/linux/guts/ftw64.c
index a375fbf..ca523d4 100644
--- a/ports/linux/guts/ftw64.c
+++ b/ports/linux/guts/ftw64.c
@@ -7,6 +7,7 @@
  *	int rc = -1;
  */
 
+	PSEUDO_USE_REAL(ftw64, return rc;);
 	rc = real_ftw64(path, fn, nopenfd);
 
 /*	return rc;
diff --git a/ports/linux/guts/glob64.c b/ports/linux/guts/glob64.c
index ccac6e4..aedb11e 100644
--- a/ports/linux/guts/glob64.c
+++ b/ports/linux/guts/glob64.c
@@ -21,6 +21,7 @@
 		alloced = 1;
 	}
 
+	PSEUDO_USE_REAL(glob64, return rc;);
 	rc = real_glob64(alloced ? rpattern : pattern, flags, errfunc, pglob);
 
 	free(rpattern);
diff --git a/ports/linux/guts/mkstemp64.c b/ports/linux/guts/mkstemp64.c
index def4126..bf317b0 100644
--- a/ports/linux/guts/mkstemp64.c
+++ b/ports/linux/guts/mkstemp64.c
@@ -24,11 +24,13 @@
 		return -1;
 	}
 
+	PSEUDO_USE_REAL(mkstemp64, return -1;);
 	rc = real_mkstemp64(tmp_template);
 
 	if (rc != -1) {
 		save_errno = errno;
 
+		PSEUDO_USE_REAL(__fxstat64, return -1;);
 		if (real___fxstat64(_STAT_VER, rc, &buf) != -1) {
 			pseudo_client_op(OP_CREAT, 0, -1, -1, tmp_template, &buf);
 			pseudo_client_op(OP_OPEN, PSA_READ | PSA_WRITE, rc, -1, tmp_template, &buf);
diff --git a/ports/linux/guts/nftw64.c b/ports/linux/guts/nftw64.c
index 82571cd..c1e2481 100644
--- a/ports/linux/guts/nftw64.c
+++ b/ports/linux/guts/nftw64.c
@@ -7,6 +7,7 @@
  *	int rc = -1;
  */
 
+	PSEUDO_USE_REAL(nftw64, return rc;);
 	rc = real_nftw64(path, fn, nopenfd, flag);
 
 /*	return rc;
diff --git a/ports/linux/guts/openat.c b/ports/linux/guts/openat.c
index 14d6c2a..e8803d9 100644
--- a/ports/linux/guts/openat.c
+++ b/ports/linux/guts/openat.c
@@ -20,8 +20,10 @@
 	if (flags & O_CREAT) {
 		save_errno = errno;
 #ifdef PSEUDO_NO_REAL_AT_FUNCTIONS
+		PSEUDO_USE_REAL(__xstat64, return -1;);
 		rc = real___xstat64(_STAT_VER, path, &buf);
 #else
+		PSEUDO_USE_REAL(__fxstatat64, return -1;);
 		rc = real___fxstatat64(_STAT_VER, dirfd, path, &buf, 0);
 #endif
 		existed = (rc != -1);
@@ -36,8 +38,10 @@
 	 * not a directory.
 	 */
 #ifdef PSEUDO_NO_REAL_AT_FUNCTIONS
+	PSEUDO_USE_REAL(open, return -1;);
 	rc = real_open(path, flags, PSEUDO_FS_MODE(mode, 0));
 #else
+	PSEUDO_USE_REAL(openat, return -1;);
 	rc = real_openat(dirfd, path, flags, PSEUDO_FS_MODE(mode, 0));
 #endif
 	save_errno = errno;
@@ -45,8 +49,10 @@
 	if (rc != -1) {
 		int stat_rc;
 #ifdef PSEUDO_NO_REAL_AT_FUNCTIONS
+		PSEUDO_USE_REAL(__xstat64, return -1;);
 		stat_rc = real___xstat64(_STAT_VER, path, &buf);
 #else
+		PSEUDO_USE_REAL(__fxstatat64, return -1;);
 		stat_rc = real___fxstatat64(_STAT_VER, dirfd, path, &buf, 0);
 #endif
 
diff --git a/ports/linux/guts/scandir.c b/ports/linux/guts/scandir.c
index afcebaf..5eae8ed 100644
--- a/ports/linux/guts/scandir.c
+++ b/ports/linux/guts/scandir.c
@@ -7,6 +7,7 @@
  *	int rc = -1;
  */
 
+	PSEUDO_USE_REAL(scandir, return rc;);
 	rc = real_scandir(path, namelist, filter, compar);
 
 /*	return rc;
diff --git a/ports/linux/guts/scandir64.c b/ports/linux/guts/scandir64.c
index 1317b73..db30913 100644
--- a/ports/linux/guts/scandir64.c
+++ b/ports/linux/guts/scandir64.c
@@ -7,6 +7,7 @@
  *	int rc = -1;
  */
 
+	PSEUDO_USE_REAL(scandir64, return rc;);
 	rc = real_scandir64(path, namelist, filter, compar);
 
 /*	return rc;
diff --git a/ports/linux/guts/truncate64.c b/ports/linux/guts/truncate64.c
index a798984..b895e0d 100644
--- a/ports/linux/guts/truncate64.c
+++ b/ports/linux/guts/truncate64.c
@@ -7,6 +7,7 @@
  *	int rc = -1;
  */
 
+	PSEUDO_USE_REAL(truncate64, return rc;);
 	rc = real_truncate64(path, length);
 
 /*	return rc;
diff --git a/ports/linux/newclone/guts/clone.c b/ports/linux/newclone/guts/clone.c
index 47dea28..86945a8 100644
--- a/ports/linux/newclone/guts/clone.c
+++ b/ports/linux/newclone/guts/clone.c
@@ -20,6 +20,7 @@
 		pseudo_dropenv();
 	}
 	/* call the real syscall */
+	PSEUDO_USE_REAL(clone, return rc;);
 	rc = (*real_clone)(fn, child_stack, flags, arg, pid, tls, ctid);
 /*	...
  *	return rc;
diff --git a/ports/linux/newclone/pseudo_wrappers.c b/ports/linux/newclone/pseudo_wrappers.c
index dd44408..f411415 100644
--- a/ports/linux/newclone/pseudo_wrappers.c
+++ b/ports/linux/newclone/pseudo_wrappers.c
@@ -20,7 +20,7 @@ clone(int (*fn)(void *), void *child_stack, int flags, void *arg, ...) {
 
 	int rc = -1;
 
-	if (!pseudo_check_wrappers() || !real_clone) {
+	if (!pseudo_check_wrappers()) {
 		/* rc was initialized to the "failure" value */
 		pseudo_enosys("clone");
 		return rc;
diff --git a/ports/linux/oldclone/guts/clone.c b/ports/linux/oldclone/guts/clone.c
index 209e4b9..f3714a8 100644
--- a/ports/linux/oldclone/guts/clone.c
+++ b/ports/linux/oldclone/guts/clone.c
@@ -20,6 +20,7 @@
 		pseudo_dropenv();
 	}
 	/* call the real syscall */
+	PSEUDO_USE_REAL(clone, return rc;);
 	rc = (*real_clone)(fn, child_stack, flags, arg);
 /*	...
  *	return rc;
diff --git a/ports/linux/oldclone/pseudo_wrappers.c b/ports/linux/oldclone/pseudo_wrappers.c
index f0bf112..4e9547a 100644
--- a/ports/linux/oldclone/pseudo_wrappers.c
+++ b/ports/linux/oldclone/pseudo_wrappers.c
@@ -14,7 +14,7 @@ clone(int (*fn)(void *), void *child_stack, int flags, void *arg) {
 
 	int rc = -1;
 
-	if (!pseudo_check_wrappers() || !real_clone) {
+	if (!pseudo_check_wrappers()) {
 		/* rc was initialized to the "failure" value */
 		pseudo_enosys("clone");
 		return rc;
diff --git a/ports/linux/pseudo_wrappers.c b/ports/linux/pseudo_wrappers.c
index 7d3fcd5..75c7888 100644
--- a/ports/linux/pseudo_wrappers.c
+++ b/ports/linux/pseudo_wrappers.c
@@ -4,15 +4,18 @@
  */
 int
 pseudo_stat(const char *path, struct stat *buf) {
+	PSEUDO_USE_REAL(__xstat, return -1;);
 	return real___xstat(_STAT_VER, path, buf);
 }
 
 int
 pseudo_lstat(const char *path, struct stat *buf) {
+	PSEUDO_USE_REAL(__lxstat, return -1;);
 	return real___lxstat(_STAT_VER, path, buf);
 }
 
 int
 pseudo_fstat(int fd, struct stat *buf) {
+	PSEUDO_USE_REAL(__fxstat, return -1;);
 	return real___fxstat(_STAT_VER, fd, buf);
 }
diff --git a/ports/unix/guts/access.c b/ports/unix/guts/access.c
index 5a92957..b0d1a04 100644
--- a/ports/unix/guts/access.c
+++ b/ports/unix/guts/access.c
@@ -11,6 +11,7 @@
 	/* note:  no attempt to handle the case where user isn't
 	 * root.
 	 */
+	PSEUDO_USE_REAL(stat, return rc;);
 	rc = real_stat(path, &buf);
 	if (rc == -1)
 		return rc;
diff --git a/ports/unix/guts/acct.c b/ports/unix/guts/acct.c
index b8dca5d..ab564d2 100644
--- a/ports/unix/guts/acct.c
+++ b/ports/unix/guts/acct.c
@@ -7,6 +7,7 @@
  *	int rc = -1;
  */
 
+	PSEUDO_USE_REAL(acct, return rc;);
 	rc = real_acct(path);
 
 /*	return rc;
diff --git a/ports/unix/guts/chdir.c b/ports/unix/guts/chdir.c
index 59a262f..357d6d7 100644
--- a/ports/unix/guts/chdir.c
+++ b/ports/unix/guts/chdir.c
@@ -13,6 +13,7 @@
 		errno = EFAULT;
 		return -1;
 	}
+	PSEUDO_USE_REAL(chdir, return rc;);
 	rc = real_chdir(path);
 
 	if (rc != -1) {
diff --git a/ports/unix/guts/close.c b/ports/unix/guts/close.c
index 09c73e6..86026c0 100644
--- a/ports/unix/guts/close.c
+++ b/ports/unix/guts/close.c
@@ -10,6 +10,7 @@
 	 * make it to the server.
 	 */
 	pseudo_client_op(OP_CLOSE, 0, fd, -1, 0, 0);
+	PSEUDO_USE_REAL(close, return rc;);
 	rc = real_close(fd);
 
 /*	return rc;
diff --git a/ports/unix/guts/dup.c b/ports/unix/guts/dup.c
index 13612b1..cfa416e 100644
--- a/ports/unix/guts/dup.c
+++ b/ports/unix/guts/dup.c
@@ -8,6 +8,7 @@
  */
  	int save_errno;
 
+	PSEUDO_USE_REAL(dup, return rc;);
 	rc = real_dup(fd);
 	save_errno = errno;
 	pseudo_debug(2, "dup: %d->%d\n", fd, rc);
diff --git a/ports/unix/guts/dup2.c b/ports/unix/guts/dup2.c
index 04666d1..cbc7618 100644
--- a/ports/unix/guts/dup2.c
+++ b/ports/unix/guts/dup2.c
@@ -12,6 +12,7 @@
 	 * server to get moved around if someone tries to overwrite it. */
 	pseudo_debug(2, "dup2: %d->%d\n", oldfd, newfd);
 	pseudo_client_op(OP_CLOSE, 0, newfd, -1, 0, 0);
+	PSEUDO_USE_REAL(dup2, return rc;);
 	rc = real_dup2(oldfd, newfd);
 	save_errno = errno;
 	pseudo_client_op(OP_DUP, 0, oldfd, newfd, 0, 0);
diff --git a/ports/unix/guts/fchdir.c b/ports/unix/guts/fchdir.c
index ba77ebf..4098499 100644
--- a/ports/unix/guts/fchdir.c
+++ b/ports/unix/guts/fchdir.c
@@ -7,6 +7,7 @@
  *	int rc = -1;
  */
 
+	PSEUDO_USE_REAL(fchdir, return rc;);
 	rc = real_fchdir(dirfd);
 
 	if (rc != -1) {
diff --git a/ports/unix/guts/fchmod.c b/ports/unix/guts/fchmod.c
index 7c6a6ad..0ffc6b5 100644
--- a/ports/unix/guts/fchmod.c
+++ b/ports/unix/guts/fchmod.c
@@ -10,12 +10,14 @@
 	struct stat buf;
 	int save_errno = errno;
 
+	PSEUDO_USE_REAL(fstat, return rc;);
 	if (real_fstat(fd, &buf) == -1) {
 		/* can't stat it, can't chmod it */
 		return -1;
 	}
 	buf.st_mode = (buf.st_mode & ~07777) | (mode & 07777);
 	msg = pseudo_client_op_plain(OP_FCHMOD, 0, fd, -1, 0, &buf);
+	PSEUDO_USE_REAL(fchmod, return rc;);
 	real_fchmod(fd, PSEUDO_FS_MODE(mode, S_ISDIR(buf.st_mode)));
 	if (msg && msg->result != RESULT_SUCCEED) {
 		errno = EPERM;
diff --git a/ports/unix/guts/fchmodat.c b/ports/unix/guts/fchmodat.c
index 5095c77..256f2ca 100644
--- a/ports/unix/guts/fchmodat.c
+++ b/ports/unix/guts/fchmodat.c
@@ -16,11 +16,14 @@
 		return -1;
 	}
 	if (flags & AT_SYMLINK_NOFOLLOW) {
+		PSEUDO_USE_REAL(lstat, return rc;);
 		rc = real_lstat(path, &buf);
 	} else {
+		PSEUDO_USE_REAL(stat, return rc;);
 		rc = real_stat(path, &buf);
 	}
 #else
+	PSEUDO_USE_REAL(__fxstatat, return rc;);
 	rc = real___fxstatat(_STAT_VER, dirfd, path, &buf, flags);
 #endif
 	if (rc == -1) {
@@ -47,8 +50,10 @@
 #ifdef PSEUDO_NO_REAL_AT_FUNCTIONS
 	/* note:  if path was a symlink, and AT_NOFOLLOW_SYMLINKS was
 	 * specified, we already bailed previously. */
+	PSEUDO_USE_REAL(chmod, return rc;);
 	real_chmod(path, PSEUDO_FS_MODE(mode, S_ISDIR(buf.st_mode)));
 #else
+	PSEUDO_USE_REAL(fchmodat, return rc;);
 	real_fchmodat(dirfd, path, PSEUDO_FS_MODE(mode, S_ISDIR(buf.st_mode)), flags);
 #endif
 	/* we ignore a failure from underlying fchmod, because pseudo
diff --git a/ports/unix/guts/fchown.c b/ports/unix/guts/fchown.c
index c36a869..c616438 100644
--- a/ports/unix/guts/fchown.c
+++ b/ports/unix/guts/fchown.c
@@ -10,6 +10,7 @@
 	struct stat buf;
 	int save_errno;
 
+	PSEUDO_USE_REAL(fstat, return rc;);
 	if (real_fstat(fd, &buf) == -1) {
 		save_errno = errno;
 		pseudo_debug(2, "fchown failing because fstat failed: %s\n",
diff --git a/ports/unix/guts/fchownat.c b/ports/unix/guts/fchownat.c
index 9585fb0..95ada57 100644
--- a/ports/unix/guts/fchownat.c
+++ b/ports/unix/guts/fchownat.c
@@ -17,11 +17,14 @@
 		return -1;
 	}
 	if (flags & AT_SYMLINK_NOFOLLOW) {
+		PSEUDO_USE_REAL(lstat, return rc;);
 		rc = real_lstat(path, &buf);
 	} else {
+		PSEUDO_USE_REAL(stat, return rc;);
 		rc = real_stat(path, &buf);
 	}
 #else
+	PSEUDO_USE_REAL(__fxstatat, return rc;);
 	rc = real___fxstatat(_STAT_VER, dirfd, path, &buf, flags);
 #endif
 	if (rc == -1) {
diff --git a/ports/unix/guts/fclose.c b/ports/unix/guts/fclose.c
index 4469f5b..f428c45 100644
--- a/ports/unix/guts/fclose.c
+++ b/ports/unix/guts/fclose.c
@@ -13,6 +13,7 @@
 	}
 	int fd = fileno(fp);
 	pseudo_client_op(OP_CLOSE, 0, fd, -1, 0, 0);
+	PSEUDO_USE_REAL(fclose, return rc;);
 	rc = real_fclose(fp);
 
 /*	return rc;
diff --git a/ports/unix/guts/fopen.c b/ports/unix/guts/fopen.c
index 9dd6c33..4378a6a 100644
--- a/ports/unix/guts/fopen.c
+++ b/ports/unix/guts/fopen.c
@@ -8,8 +8,10 @@
  */
  	struct stat buf;
 	int save_errno;
+	PSEUDO_USE_REAL(stat, return rc;);
 	int existed = (real_stat(path, &buf) != -1);
 
+	PSEUDO_USE_REAL(fopen, return rc;);
 	rc = real_fopen(path, mode);
 	save_errno = errno;
 
@@ -17,6 +19,7 @@
 		int fd = fileno(rc);
 
 		pseudo_debug(2, "fopen '%s': fd %d <FILE %p>\n", path, fd, (void *) rc);
+		PSEUDO_USE_REAL(fstat, return rc;);
 		if (real_fstat(fd, &buf) != -1) {
 			if (!existed) {
 				pseudo_client_op_plain(OP_CREAT, 0, -1, -1, path, &buf);
diff --git a/ports/unix/guts/freopen.c b/ports/unix/guts/freopen.c
index b5a7bfc..51fd65b 100644
--- a/ports/unix/guts/freopen.c
+++ b/ports/unix/guts/freopen.c
@@ -8,8 +8,10 @@
  */
  	struct stat buf;
 	int save_errno;
+	PSEUDO_USE_REAL(stat, return rc;);
 	int existed = (real_stat(path, &buf) != -1);
 
+	PSEUDO_USE_REAL(freopen, return rc;);
 	rc = real_freopen(path, mode, stream);
 	save_errno = errno;
 
@@ -17,6 +19,7 @@
 		int fd = fileno(rc);
 
 		pseudo_debug(2, "freopen '%s': fd %d\n", path, fd);
+		PSEUDO_USE_REAL(fstat, return rc;);
 		if (real_fstat(fd, &buf) != -1) {
 			if (!existed) {
 				pseudo_client_op_plain(OP_CREAT, 0, -1, -1, path, &buf);
diff --git a/ports/unix/guts/fts_open.c b/ports/unix/guts/fts_open.c
index 8b3ce19..ce2923d 100644
--- a/ports/unix/guts/fts_open.c
+++ b/ports/unix/guts/fts_open.c
@@ -35,6 +35,7 @@
 		errno = ENOMEM;
 		rc = NULL;
 	} else {
+		PSEUDO_USE_REAL(fts_open, return rc;);
 		rc = real_fts_open(path_argv, options, compar);
 	}
 	for (i = 0; i < args; ++i)
diff --git a/ports/unix/guts/ftw.c b/ports/unix/guts/ftw.c
index 0861194..e5b74ec 100644
--- a/ports/unix/guts/ftw.c
+++ b/ports/unix/guts/ftw.c
@@ -7,6 +7,7 @@
  *	int rc = -1;
  */
 
+	PSEUDO_USE_REAL(ftw, return rc;);
 	rc = real_ftw(path, fn, nopenfd);
 
 /*	return rc;
diff --git a/ports/unix/guts/glob.c b/ports/unix/guts/glob.c
index 0012179..9fbc4ba 100644
--- a/ports/unix/guts/glob.c
+++ b/ports/unix/guts/glob.c
@@ -21,6 +21,7 @@
 		alloced = 1;
 	}
 
+	PSEUDO_USE_REAL(glob, return rc;);
 	rc = real_glob(alloced ? rpattern : pattern, flags, errfunc, pglob);
 
 	free(rpattern);
diff --git a/ports/unix/guts/link.c b/ports/unix/guts/link.c
index 81316e2..5889230 100644
--- a/ports/unix/guts/link.c
+++ b/ports/unix/guts/link.c
@@ -9,6 +9,7 @@
  	pseudo_msg_t *msg;
  	struct stat buf;
 
+	PSEUDO_USE_REAL(link, return rc;);
 	rc = real_link(oldpath, newpath);
 	if (rc == 0) {
 		/* link(2) will not overwrite; if it succeeded, we know
@@ -19,6 +20,7 @@
 		 * files they link to.  This is contraPOSIX, but
 		 * it's apparently useful.
 		 */
+		PSEUDO_USE_REAL(lstat, return rc;);
 		real_lstat(oldpath, &buf);
 		/* a link should copy the existing database entry, if
 		 * there is one.  OP_LINK is also used to insert unseen
diff --git a/ports/unix/guts/lutimes.c b/ports/unix/guts/lutimes.c
index cdadbbd..b5a74ba 100644
--- a/ports/unix/guts/lutimes.c
+++ b/ports/unix/guts/lutimes.c
@@ -7,6 +7,7 @@
  *	int rc = -1;
  */
 
+	PSEUDO_USE_REAL(lutimes, return rc;);
 	rc = real_lutimes(path, tv);
 
 /*	return rc;
diff --git a/ports/unix/guts/mkdirat.c b/ports/unix/guts/mkdirat.c
index 97141fc..ff5c073 100644
--- a/ports/unix/guts/mkdirat.c
+++ b/ports/unix/guts/mkdirat.c
@@ -11,8 +11,10 @@
 		errno = ENOSYS;
 		return -1;
 	}
+	PSEUDO_USE_REAL(mkdir, return rc;);
 	rc = real_mkdir(path, PSEUDO_FS_MODE(mode, 1));
 #else
+	PSEUDO_USE_REAL(mkdirat, return rc;);
 	rc = real_mkdirat(dirfd, path, PSEUDO_FS_MODE(mode, 1));
 #endif
 	if (rc != -1) {
@@ -20,8 +22,10 @@
 		int stat_rc;
 
 #ifdef PSEUDO_NO_REAL_AT_FUNCTIONS
+		PSEUDO_USE_REAL(lstat, return rc;);
 		stat_rc = real_lstat(path, &buf);
 #else
+		PSEUDO_USE_REAL(__fxstatat, return rc;);
 		stat_rc = real___fxstatat(_STAT_VER, dirfd, path, &buf, AT_SYMLINK_NOFOLLOW);
 #endif
 		if (stat_rc != -1) {
diff --git a/ports/unix/guts/mkdtemp.c b/ports/unix/guts/mkdtemp.c
index 92d4da7..fb16eeb 100644
--- a/ports/unix/guts/mkdtemp.c
+++ b/ports/unix/guts/mkdtemp.c
@@ -24,11 +24,13 @@
 		return NULL;
 	}
 
+	PSEUDO_USE_REAL(mkdtemp, return NULL;);
 	rc = real_mkdtemp(tmp_template);
 
 	if (rc != NULL) {
 		save_errno = errno;
 
+		PSEUDO_USE_REAL(mkdtemp, return NULL;);
 		if (real_stat(rc, &buf) != -1) {
 			pseudo_client_op_plain(OP_CREAT, 0, -1, -1, tmp_template, &buf);
 		} else {
diff --git a/ports/unix/guts/mknod.c b/ports/unix/guts/mknod.c
index 25c2962..0539fb5 100644
--- a/ports/unix/guts/mknod.c
+++ b/ports/unix/guts/mknod.c
@@ -6,6 +6,7 @@
  *	int rc = -1;
  */
 
+	PSEUDO_USE_REAL(mknod, return rc;);
 	rc = real_mknod(path, mode, dev);
 
 /*	return rc;
diff --git a/ports/unix/guts/mknodat.c b/ports/unix/guts/mknodat.c
index 2b24cd0..1f8b3c8 100644
--- a/ports/unix/guts/mknodat.c
+++ b/ports/unix/guts/mknodat.c
@@ -14,8 +14,10 @@
 		errno = ENOSYS;
 		return -1;
 	}
+	PSEUDO_USE_REAL(stat, return -1;);
 	rc = real_stat(path, &buf);
 #else
+	PSEUDO_USE_REAL(__fxstatat, return -1;);
 	rc = real___fxstatat(_STAT_VER, dirfd, path, &buf, AT_SYMLINK_NOFOLLOW);
 #endif
 	if (rc != -1) {
@@ -24,20 +26,24 @@
 		return -1;
 	}
 #ifdef PSEUDO_NO_REAL_AT_FUNCTIONS
+	PSEUDO_USE_REAL(open, return -1;);
 	rc = real_open(path, O_CREAT | O_WRONLY | O_EXCL,
 		PSEUDO_FS_MODE(mode, 0));
 #else
+	PSEUDO_USE_REAL(openat, return -1;);
 	rc = real_openat(dirfd, path, O_CREAT | O_WRONLY | O_EXCL,
 		PSEUDO_FS_MODE(mode, 0));
 #endif
 	if (rc == -1) {
 		return -1;
 	}
+	PSEUDO_USE_REAL(fstat, return -1;);
 	real_fstat(rc, &buf);
 	/* mknod does not really open the file.  We don't have
 	 * to use wrap_close because we've never exposed this file
 	 * descriptor to the client code.
 	 */
+	PSEUDO_USE_REAL(close, return -1;);
 	real_close(rc);
 
 	/* mask in the mode type bits again */
@@ -55,8 +61,10 @@
 	if (rc == -1) {
 		int save_errno = errno;
 #ifdef PSEUDO_NO_REAL_AT_FUNCTIONS
+		PSEUDO_USE_REAL(unlink, return -1;);
 		real_unlink(path);
 #else
+		PSEUDO_USE_REAL(unlinkat, return -1;);
 		real_unlinkat(dirfd, path, AT_SYMLINK_NOFOLLOW);
 #endif
 		errno = save_errno;
diff --git a/ports/unix/guts/mkstemp.c b/ports/unix/guts/mkstemp.c
index 46c0be1..3e6136e 100644
--- a/ports/unix/guts/mkstemp.c
+++ b/ports/unix/guts/mkstemp.c
@@ -24,6 +24,7 @@
 		return -1;
 	}
 
+	PSEUDO_USE_REAL(mkstemp, return -1;);
 	rc = real_mkstemp(tmp_template);
 
 	if (rc != -1) {
diff --git a/ports/unix/guts/mktemp.c b/ports/unix/guts/mktemp.c
index 7cf594a..d80bd68 100644
--- a/ports/unix/guts/mktemp.c
+++ b/ports/unix/guts/mktemp.c
@@ -22,6 +22,7 @@
 		return NULL;
 	}
 
+	PSEUDO_USE_REAL(mktemp, return NULL;);
 	rc = real_mktemp(tmp_template);
 
 	/* mktemp only changes the XXXXXX at the end, and never created
diff --git a/ports/unix/guts/nftw.c b/ports/unix/guts/nftw.c
index 73daec8..18c2601 100644
--- a/ports/unix/guts/nftw.c
+++ b/ports/unix/guts/nftw.c
@@ -7,6 +7,7 @@
  *	int rc = -1;
  */
 
+	PSEUDO_USE_REAL(nftw, return rc;);
 	rc = real_nftw(path, fn, nopenfd, flag);
 
 /*	return rc;
diff --git a/ports/unix/guts/opendir.c b/ports/unix/guts/opendir.c
index 8eaa71f..47f5884 100644
--- a/ports/unix/guts/opendir.c
+++ b/ports/unix/guts/opendir.c
@@ -7,6 +7,7 @@
  *	DIR * rc = NULL;
  */
 
+	PSEUDO_USE_REAL(opendir, return rc;);
 	rc = real_opendir(path);
 
 /*	return rc;
diff --git a/ports/unix/guts/pathconf.c b/ports/unix/guts/pathconf.c
index c6caa34..1248c0c 100644
--- a/ports/unix/guts/pathconf.c
+++ b/ports/unix/guts/pathconf.c
@@ -7,6 +7,7 @@
  *	long rc = -1;
  */
 
+	PSEUDO_USE_REAL(pathconf, return rc;);
 	rc = real_pathconf(path, name);
 
 /*	return rc;
diff --git a/ports/unix/guts/readlinkat.c b/ports/unix/guts/readlinkat.c
index 5282e2b..5519e89 100644
--- a/ports/unix/guts/readlinkat.c
+++ b/ports/unix/guts/readlinkat.c
@@ -11,8 +11,10 @@
 		errno = ENOSYS;
 		return -1;
 	}
+	PSEUDO_USE_REAL(readlink, return rc;);
 	rc = real_readlink(path, buf, bufsiz);
 #else
+	PSEUDO_USE_REAL(readlinkat, return rc;);
 	rc = real_readlinkat(dirfd, path, buf, bufsiz);
 #endif
 
diff --git a/ports/unix/guts/remove.c b/ports/unix/guts/remove.c
index 902a640..cbc48a6 100644
--- a/ports/unix/guts/remove.c
+++ b/ports/unix/guts/remove.c
@@ -7,13 +7,16 @@
  *	int rc = -1;
  */
 	struct stat buf;
+	PSEUDO_USE_REAL(lstat, return rc;);
 	if (real_lstat(path, &buf) == -1) {
 		errno = ENOENT;
 		return -1;
 	}
 	if (S_ISDIR(buf.st_mode)) {
+		PSEUDO_USE_REAL(rmdir, return rc;);
 		rc = wrap_rmdir(path);
 	} else {
+		PSEUDO_USE_REAL(unlink, return rc;);
 		rc = wrap_unlink(path);
 	}
 
diff --git a/ports/unix/guts/rename.c b/ports/unix/guts/rename.c
index 04892c1..3a7b2c4 100644
--- a/ports/unix/guts/rename.c
+++ b/ports/unix/guts/rename.c
@@ -23,7 +23,9 @@
 
 	save_errno = errno;
 
+	PSEUDO_USE_REAL(lstat, return rc;);
 	newrc = real_lstat(newpath, &newbuf);
+	PSEUDO_USE_REAL(lstat, return rc;);
 	oldrc = real_lstat(oldpath, &oldbuf);
 
 	errno = save_errno;
@@ -33,6 +35,7 @@
 	msg = pseudo_client_op_plain(OP_MAY_UNLINK, 0, -1, -1, newpath, newrc ? NULL : &newbuf);
 	if (msg && msg->result == RESULT_SUCCEED)
 		old_db_entry = 1;
+	PSEUDO_USE_REAL(rename, return rc;);
 	rc = real_rename(oldpath, newpath);
 	save_errno = errno;
 	if (old_db_entry) {
diff --git a/ports/unix/guts/renameat.c b/ports/unix/guts/renameat.c
index c8203b7..8f24565 100644
--- a/ports/unix/guts/renameat.c
+++ b/ports/unix/guts/renameat.c
@@ -8,6 +8,7 @@
  */
 
 	pseudo_diag("help! unimplemented renameat [%s -> %s].\n", oldpath, newpath);
+	PSEUDO_USE_REAL(renameat, return rc;);
 	rc = real_renameat(olddirfd, oldpath, newdirfd, newpath);
 
 /*	return rc;
diff --git a/ports/unix/guts/rmdir.c b/ports/unix/guts/rmdir.c
index 7307fcd..78acef3 100644
--- a/ports/unix/guts/rmdir.c
+++ b/ports/unix/guts/rmdir.c
@@ -11,6 +11,7 @@
 	int save_errno;
 	int old_db_entry = 0;
 
+	PSEUDO_USE_REAL(lstat, return rc;);
 	rc = real_lstat(path, &buf);
 	if (rc == -1) {
 		return rc;
@@ -18,6 +19,7 @@
 	msg = pseudo_client_op_plain(OP_MAY_UNLINK, 0, -1, -1, path, &buf);
 	if (msg && msg->result == RESULT_SUCCEED)
 		old_db_entry = 1;
+	PSEUDO_USE_REAL(rmdir, return rc;);
 	rc = real_rmdir(path);
 	if (old_db_entry) {
 		if (rc == -1) {
diff --git a/ports/unix/guts/symlinkat.c b/ports/unix/guts/symlinkat.c
index 9912c31..ec6ae62 100644
--- a/ports/unix/guts/symlinkat.c
+++ b/ports/unix/guts/symlinkat.c
@@ -20,8 +20,10 @@
 		errno = ENOSYS;
 		return -1;
 	}
+	PSEUDO_USE_REAL(symlink, return -1;);
 	rc = real_symlink(roldname ? roldname : oldname, newpath);
 #else
+	PSEUDO_USE_REAL(symlinkat, return -1;);
 	rc = real_symlinkat(roldname ? roldname : oldname, dirfd, newpath);
 #endif
 
@@ -30,8 +32,10 @@
 		return rc;
 	}
 #ifdef PSEUDO_NO_REAL_AT_FUNCTIONS
+	PSEUDO_USE_REAL(lstat, return -1;);
 	rc = real_lstat(newpath, &buf);
 #else
+	PSEUDO_USE_REAL(__fxstatat, return -1;);
 	rc = real___fxstatat(_STAT_VER, dirfd, newpath, &buf, AT_SYMLINK_NOFOLLOW);
 #endif
 	if (rc == -1) {
diff --git a/ports/unix/guts/system.c b/ports/unix/guts/system.c
index 8b3607d..7507270 100644
--- a/ports/unix/guts/system.c
+++ b/ports/unix/guts/system.c
@@ -14,6 +14,7 @@
 		return 1;
 
 	pseudo_setupenv();
+	PSEUDO_USE_REAL(system, return rc;);
 	rc = real_system(command);
 
 /*	return rc;
diff --git a/ports/unix/guts/truncate.c b/ports/unix/guts/truncate.c
index 6a19a50..db8b08d 100644
--- a/ports/unix/guts/truncate.c
+++ b/ports/unix/guts/truncate.c
@@ -7,6 +7,7 @@
  *	int rc = -1;
  */
 
+	PSEUDO_USE_REAL(truncate, return rc;);
 	rc = real_truncate(path, length);
 
 /*	return rc;
diff --git a/ports/unix/guts/unlinkat.c b/ports/unix/guts/unlinkat.c
index 7b51ab9..8e04e45 100644
--- a/ports/unix/guts/unlinkat.c
+++ b/ports/unix/guts/unlinkat.c
@@ -29,8 +29,10 @@
 #endif
 
 #ifdef PSEUDO_NO_REAL_AT_FUNCTIONS
+	PSEUDO_USE_REAL(lstat, return -1;);
 	rc = real_lstat(path, &buf);
 #else
+	PSEUDO_USE_REAL(__fxstatat, return -1;);
 	rc = real___fxstatat(_STAT_VER, dirfd, path, &buf, AT_SYMLINK_NOFOLLOW);
 #endif
 	if (rc == -1) {
@@ -40,8 +42,10 @@
 	if (msg && msg->result == RESULT_SUCCEED)
 		old_db_entry = 1;
 #ifdef PSEUDO_NO_REAL_AT_FUNCTIONS
+	PSEUDO_USE_REAL(unlink, return -1;);
 	rc = real_unlink(path);
 #else
+	PSEUDO_USE_REAL(unlinkat, return -1;);
 	rc = real_unlinkat(dirfd, path, rflags);
 #endif
 	if (old_db_entry) {
diff --git a/ports/unix/guts/utime.c b/ports/unix/guts/utime.c
index ff65237..14bc018 100644
--- a/ports/unix/guts/utime.c
+++ b/ports/unix/guts/utime.c
@@ -6,6 +6,7 @@
  * wrap_utime(const char *path, const struct utimbuf *buf) {
  *	int rc = -1;
  */
+	PSEUDO_USE_REAL(utime, return rc;);
 	rc = real_utime(path, buf);
 
 /*	return rc;
diff --git a/ports/unix/guts/utimes.c b/ports/unix/guts/utimes.c
index 69ad949..ddf8206 100644
--- a/ports/unix/guts/utimes.c
+++ b/ports/unix/guts/utimes.c
@@ -6,6 +6,7 @@
  * wrap_utimes(const char *path, const struct timeval *times) {
  *	int rc = -1;
  */
+	PSEUDO_USE_REAL(utimes, return rc;);
 	rc = real_utimes(path, times);
 
 /*	return rc;
diff --git a/pseudo.h b/pseudo.h
index 297d6d8..a87e05b 100644
--- a/pseudo.h
+++ b/pseudo.h
@@ -20,8 +20,13 @@
 #include <stdlib.h>
 #include <fcntl.h>
 
+/* #define PSEUDO_LAZY_EVAL */
+
 /* List of magic initialization functions... */
 extern void pseudo_init_wrappers(void);
+#ifdef PSEUDO_LAZY_EVAL
+extern int pseudo_init_real(const char *func_name);
+#endif
 extern void pseudo_init_util(void);
 extern void pseudo_init_client(void);
 
diff --git a/pseudo_wrappers.c b/pseudo_wrappers.c
index f11f172..5a2644e 100644
--- a/pseudo_wrappers.c
+++ b/pseudo_wrappers.c
@@ -127,6 +127,7 @@ pseudo_init_one_wrapper(pseudo_function *func) {
 	}
 }
 
+#ifndef PSEUDO_LAZY_EVAL
 void
 pseudo_init_wrappers(void) {
 	int i;
@@ -153,6 +154,55 @@ pseudo_init_wrappers(void) {
 	pseudo_magic();
 	pseudo_droplock();
 }
+#else /* defined PSEUDO_LAZY_EVAL */
+void
+pseudo_init_wrappers(void) {
+	pseudo_getlock();
+	pseudo_antimagic();
+
+	pseudo_logfile(NULL);
+
+	pseudo_magic();
+	pseudo_droplock();
+}
+
+int
+pseudo_init_real(const char *func_name) {
+	int i;
+
+#if 0
+	/* Enable to track lazy init..  not a pseudo_debug because
+	 * of the potential overhead.
+	 */
+	pseudo_diag("init: %s\n", func_name);
+#endif
+
+	if (!func_name)
+		return 1;
+
+	pseudo_function *func = (pseudo_function *)NULL;
+
+	for (i = 0; pseudo_functions[i].name; ++i) {
+		if (!strcmp(func_name, pseudo_functions[i].name)) {
+			func = &pseudo_functions[i];
+			break;
+		}
+	}
+
+	if (!func)
+		return 1;
+
+	pseudo_getlock();
+	pseudo_init_one_wrapper(func);
+	pseudo_droplock();
+
+        if (*func->real != NULL)
+                return 0;
+
+	return 1;
+}
+
+#endif /* PSEUDO_LAZY_EVAL */
 
 static void
 pseudo_sigblock(sigset_t *saved) {
diff --git a/templates/wrapfuncs.c b/templates/wrapfuncs.c
index 0d0fb52..678f9ce 100644
--- a/templates/wrapfuncs.c
+++ b/templates/wrapfuncs.c
@@ -23,7 +23,7 @@ ${name}(${decl_args}) {
 	${variadic_decl}
 	${rc_decl}
 
-	if (!pseudo_check_wrappers() || !real_$name) {
+	if (!pseudo_check_wrappers()) {
 		/* rc was initialized to the "failure" value */
 		pseudo_enosys("${name}");
 		${rc_return}
@@ -32,6 +32,7 @@ ${name}(${decl_args}) {
 	${variadic_start}
 
 	if (pseudo_disabled) {
+		PSEUDO_USE_REAL(${name}, ${rc_return});
 		${rc_assign} (*real_${name})(${call_args});
 		${variadic_end}
 		${rc_return}
@@ -48,6 +49,7 @@ ${name}(${decl_args}) {
 	int save_errno;
 	if (antimagic > 0) {
 		/* call the real syscall */
+		PSEUDO_USE_REAL(${name}, ${rc_return});
 		${rc_assign} (*real_${name})(${call_args});
 	} else {
 		${alloc_paths}
diff --git a/templates/wrapfuncs.h b/templates/wrapfuncs.h
index 1ce4fcc..e51799f 100644
--- a/templates/wrapfuncs.h
+++ b/templates/wrapfuncs.h
@@ -4,6 +4,29 @@
 
 /* This file is generated and should not be modified.  See the makewrappers
  * script if you want to modify this. */
+
+/* Define used to handle the mapping and validation of the "real" function
+ */
+
+#define PSEUDO_REAL_NAME(x) #x
+#define PSEUDO_REAL_UNDERSCORE(x) real_ ## x
+
+#ifndef PSEUDO_LAZY_EVAL
+#define PSEUDO_USE_REAL(x, rc_return) \
+	if (!PSEUDO_REAL_UNDERSCORE(x)) { \
+		/* rc was initialized to the "failure" value */ \
+		pseudo_enosys(PSEUDO_REAL_NAME(x)); \
+		rc_return \
+	}
+#else /* defined PSEUDO_LAZY_EVAL */
+#define PSEUDO_USE_REAL(x, rc_return) \
+	if (!PSEUDO_REAL_UNDERSCORE(x) && pseudo_init_real(PSEUDO_REAL_NAME(x))) { \
+		/* rc was initialized to the "failure" value */ \
+		pseudo_enosys(PSEUDO_REAL_NAME(x)); \
+		rc_return \
+	}
+#endif /* PSEUDO_LAZY_EVAL */
+
 @body
 /* ${comment} */
 static ${type} wrap_${name}(${wrap_args});
